#PWscf
####It can do:

* ground-state energy and one-electron (Kohn-Sham) orbitals, atomic forces, stresses;
* structural optimization, also with variable cell;
* molecular dynamics on the Born-Oppenheimer surface, also with variable cell;
* macroscopic polarization and ﬁnite electric ﬁelds via the modern theory of polarization (Berry Phases);
* modern theory of orbital magnetization;
* free-energy  surface  calculation  at  ﬁxed cell  through  meta-dynamics,  if  patched  with PLUMED.

####Tools in PW/tools:

* **kpoints.x** produces lists of k-points
* **bs.awk, mv.awk** process the output of pw.x
* **ev.x** fits energy-vs-volume data to an equation of state
* **cif2qe.sh** converting from CIF to a format suitable for QUANTUM ESPRESSO
* **dist.x**  reads input data for **PWscf**, calculates distances and angles between atoms in a cell periodically
* **pwi2xsf.sh, pwo2xsf.sh** process respectively input and output files for **pw.x** and produce and XSF-formatted file suitable for plotting with XCrySDen


***

####Input data:

#####NAMELISTS:

* **&CONTROL** general variables controlling the run
* **&SYSTEM** structural  information on the system under investigation
* **&ELECTRONS** electronic variables: self-consistency, smearing
* **&IONS** ( *optional* ) ionic variables: relaxation, dynamics
* **&CELL** ( *optional* ) variable-cell optimization or dynamics

#####AND CARDS:

* **ATOMIC\_SPECIES**
* **ATOMIC\_POSITIONS**
* **K\_POINTS**
* **CELL\_PARAMETERS** ( *optional* )
* **OCCUPATIONS** ( *optional* )

####All the variables have default values **EXCEPT**:

* **ibrav** ( *integer* ) : Bravais\_lattice index
* **celldm** ( *real, dimension 6* ) : crystallographic constants
* **nat** ( *integer* ) : number of atoms in the unit cell
* **ntyp** ( *integer* ) : number of types of atoms in the unit cell
* **ecutwfc** ( *real* ) : kinetic energy cutoff (Ry) for wavefunctions.    


***
###Input files instruction
####&CONTROL

*    **calculation** = **'scf'**, 'nscf', bands', 'relax', 'md', 'vc-relax', 'vc-md'

      *vc: variable-cell*
*  **title** = **'_CHARACTER_'**

*  **verbosity** = **'low'**, 'high'

*  **restart\_mode** = **'from\_scratch'**, 'restart'

*  **wf\_collect** = **.FALSE.**, .TRUE.

    to store wavefunctions or not

*  **nstep** = **1** *for scf, nscf, bands calculation*, **50** *for others*

    number of ionic + electronic steps

*  **iprint** = ???

*  **tstress**, **tprnfor** = **.TRUE.** *for vc-md, vc- relax calculation*, **.FALSE.** *for others*

    calculate stress and calculate forces

*  **dt** = **20.D0**

    time step for molecular dynamics. in Rydberg atomic units (1 a.u.=4.8378 * 10^-17 s : beware, the CP code uses  Hartree atomic units, half that much

*  **outdir** = **'./'**

    input, temporary, output files are found in this directory

*  **wfcdir** = *same as*  **"outdir"**

    this directory specifies where to store files generated by each processor in order to restart from interrupted runs, or to perform further calculations using the produced data files, you may need to copy files to "outdir". Works only for pw.x.

*  **prefix** = **'pwscf'**

    prepended to input/output filenames

*  **lkpoint\_dir** = **'.TRUE.'**, .FALSE.

    false for a single file for all k-points

*  **max\_seconds** = **1.D+7** *or* **150 days**

    jobs stops after "max\_seconds" CPU time

*  **etot\_conv\_thr** = **1.0D-4**

    convergence threshold on total energy (a.u) for ionic minimization

*  **forc\_conv\_thr** = **1.0D-3**

    convergence threshold on forces (a.u) for ionic minimization

*  **disk\_io** = **'low'** *for scf calculation*, **'medium'** *for others*, 'high', 'none'

    'high':   save all data to disk at each SCF step;   
    'medium': save wavefunctions at each SCF step unless
          there is a single k-point per process (in which
          case the behavior is the same as 'low');   
     'low' :   store wfc in memory, save only at the end;  
     'none':   do not save anything, not even at the end.

*  **pseudo\_dir** = **$ESPRESSO\_PSEUDO** *or* **$HOME/espresso/pseudo/**

    directory containing pseudopotential files

*  **tefield** = **.FALSE.**, .TRUE.

    .TRUE. for a saw-like potential simulating an electric field added to the bare ionic potential

*  **dipfield** = **.FALSE.**, .TRUE.

    .TRUE. and tefield=.TRUE. for a dipole correction is also added to the bare ionic potential. Must be used ONLY in a slab geometry, for surface calculations, with the discontinuity FALLING IN THE EMPTY SPACE.

*  **lelfield** = **.FALSE.**, .TRUE.

    .TRUE. for a homogeneous finite electric field described through the modern theory of the polarization is applied

*  **nberrycyc** = **1**

    In the case of a finite electric field  ( lelfield == .TRUE. ) it defines the number of iterations for converging the wavefunctions in the electric field Hamiltonian, for each external iteration on the charge density

*  **lorbm** = **.FALSE.**, .TRUE.

    .TRUE. perform orbital magnetization calculation. If finite electric field is applied (lelfield=.true.) only Kubo terms are computed

*  **lberry** = **.FALSE.**

    .TRUE.  for perform a Berry phase calculation

*  **gdir** = *INTEGER*

    For Berry phase calculation: direction of the k-point strings in reciprocal space.Allowed values: 1, 2, 3: 1=first, 2=second, 3=third reciprocal lattice vector

    For calculations with finite electric fields (lelfield==.true.) "gdir" is the direction of the field

*  **nppstr** = *INTEGER*

    For Berry phase calculation: number of k-points to be calculated along each symmetry-reduced string The same for calculation with finite electric fields (lelfield=.true.)  

/
####&SYSTEM

*  **ibrav** = *INTEGER*

    Bravais-lattice index. If ibrav /= 0, specify EITHER   [ celldm(1)-celldm(6) ] OR [ A,B,C,cosAB,cosAC,cosBC ]  but NOT both. The lattice parameter "alat" is set to  alat = celldm(1) (in a.u.) or alat = A (in Angstrom);

    For ibrav=0 specify the lattice vectors in CELL\_PARAMETER,  optionally the lattice parameter alat = celldm(1) (in a.u.)  or = A (in Angstrom), or else it is taken from CELL\_PARAMETERS

    |ibrav|structure|celldm(2)-celldm(6) or b, c, cosab, cosac, cosbc|
    |---:|:----:|:---|
    |0|free|crystal axis provided input *see card CELL\_PARAMETERS*|
    |1|cubic P (sc)| |
    |2|cubic F (fcc)| |
    |3|cubic I (bcc)| |
    |4|Hexagonal and Trigonal P|celldm(3)=c/a|
    |5|Trigonal R, 3fold axis c|celldm(4)=cos(alpha)|
    |-5|Trigonal R, 3fold axis <111>|celldm(4)=cos(alpha)|
    |6|Tetragonal P (st)|celldm(3)=c/a|
    |7|Tetragonal I (bct)|celldm(3)=c/a|
    |8|Orthorhombic P|celldm(2)=b/a, celldm(3)=c/a|
    |9|Orthorhombic base-centered(bco)|celldm(2)=b/a, celldm(3)=c/a|
    |-9|*as 9, alternate description*| |
    |10|Orthorhombic face-centered|celldm(2)=b/a, celldm(3)=c/a|
    |11|Orthorhombic body-centered|celldm(2)=b/a, celldm(3)=c/a|
    |12|Monoclinic P, unique axis c|celldm(2)=b/a, celldm(3)=c/a, celldm(4)=cos(ab)|
    |-12|Monoclinic P, unique axis b|celldm(2)=b/a, celldm(3)=c/a, celldm(5)=cos(ac)|
    |13|Monoclinic base-centered|celldm(2)=b/a, celldm(3)=c/a, celldm(4)=cos(ab)|
    |14|Triclinic|celldm(2)= b/a, celldm(3)= c/a, celldm(4)= cos(bc), celldm(5)= cos(ac), celldm(6)= cos(ab)|

    * **cellm(i), i=1,6** = *REAL*

        Crystallographic constants - see the "ibrav" variable. Specify either these OR A,B,C,cosAB,cosBC,cosAC NOT both. Only needed values (depending on "ibrav") must be specified alat = celldm(1) is the lattice parameter "a" (in BOHR) If ibrav=0, only celldm(1) is used if present; cell vectors are read from card CELL\_PARAMETERS

    * *or* **A, B, C, cosAB, cosAC, cosBC** = *REAL*

        Traditional crystallographic constants: a,b,c in ANGSTROM: cosAB = cosine of the angle between axis a and b (gamma); cosAC = cosine of the angle between axis a and c (beta); cosBC = cosine of the angle between axis b and c (alpha). The axis are chosen according to the value of "ibrav". Specify either these OR "celldm" but NOT both. Only needed values (depending on "ibrav") must be specified. The lattice parameter alat = A (in ANGSTROM ). If ibrav = 0, only A is used if present; cell vectors are read from card CELL\_PARAMETERS

*  **nat** = *INTEGER*

    number of atoms in the unit cell

*  **ntyp** = *INTEGER*

    number of types of atoms in the unit cell

*  **nbnd** = **number of valence bands** *for an insulator*, **20% more** *for a metal*

    number of electronic states (bands) to be calculated. Note that in spin-polarized calculations the number of k-point, not the number of bands per k-point, is doubled.

*  **tot\_charge** = **0.0**

    total charge of the system. tot\_charge=+1 means one electron missing from the system, tot\_charge=-1 means one additional electron, and so on.

*  **tot\_magnetization** =  **\[unspecified\]** *or* **-1**

    total majority spin charge - minority spin charge.

*  **starting\_magnetization(i), i=1,ntyp** = **0**

*  **ecutwfc** = *REAL*

    kinetic energy cutoff (Ry) for wavefunctions

*  **ecutrho** = **4\*\[ecutwfc\]**

    kinetic energy cutoff (Ry) for charge density and potential

*  **ecutfock** = **\[ecutrho\]**

    kinetic energy cutoff (Ry) for the exact exchange operator in EXX type calculations

*  **nr1, nr2, nr3** = *INTEGER*

    three-dimensional FFT mesh (hard grid) for charge density (and scf potential). If not specified
the grid is calculated based on the cutoff for charge density (see also "ecutrho") Note: you must specify all three dimensions for this setting to be used.

*  **nr1s, nr2s, nr3s** = *INTEGER*

    three-dimensional mesh for wavefunction FFT and for the smooth part of charge density ( smooth grid ). Note: you must specify all three dimensions for this setting to be used.

*  **nosym** = **.FALSE.**, .TRUE.

    .TRUE. for not using symmetry.

*  **nosym\_evc** = **.FALSE.**, .TRUE.

     .TRUE. for not using symmetry, but the k-points are forced to have the symmetry of the Bravais lattice.

*  **noinv** = **.FALSE.**, .TRUE.

    .TRUE. disable the usage of k => -k symmetry (time reversal) in k-point generation

*  **no\_t\_rev** = **.FALSE.**, .TRUE.

    .TRUE. disable the usage of magnetic symmetry operations that consist in a rotation + time reversal.

*  **force\_symmorphic** = **.FALSE.**, .TRUE.

    .TRUE. force the symmetry group to be symmorphic by disabling symmetry operations having an associated fractionary translation

*  **use\_all\_frac** = **.FALSE.**, .TRUE.

    .TRUE. do not discard symmetry operations with an associated fractionary translation that does not send the real-space FFT grid into itself.

*  **occupations** = 'smearing', 'tetrahedra', 'fixed', 'from\_input'

    'smearing':     gaussian smearing for metals

    'tetrahedra' :  especially suited for calculation of DOS

    'fixed' :       for insulators with a gap

    'from_input' :  The occupation are read from input file, card OCCUPATIONS. Option valid only for a single k-point, requires "nbnd" to be set in input. Occupations should be consistent                with the value of "tot\_charge"

*  **one\_atom\_occupations** = **.FALSE.**, .TRUE.

    This flag is used for isolated atoms (nat=1) together with occupations='from\_input'

*  **starting\_spin\_angle** = **.FALSE.**, .TRUE.

    ???

*  **degauss** = **0.D0**

    value of the gaussian spreading (Ry) for brillouin-zone integration in metals

*  **smearing** = **'gaussian'**(gauss), 'methfessel-paxton'(m-p, mp), 'marzari-vanderbilt'(cold, m-v, mv), 'fermi-dirac'(f-d,fd)

    'gaussian': ordinary Gaussian spreading (Default)

    'methfessel-paxton': Methfessel-Paxton first-order spreading

    'marzari-vanderbilt':  Marzari-Vanderbilt cold smearing

    'fermi-dirac': smearing with Fermi-Dirac function

*  **nspin** = **1**, 2, 4

    1 :  non-polarized calculation (default)

    2 :  spin-polarized calculation, LSDA (magnetization along z axis)

    4 :  spin-polarized calculation, noncollinear (magnetization in generic direction). DO NOT specify nspin in this case; specify "noncolin=.TRUE." instead

*  **noncolin** = **.FALSE.**, .TRUE.

    .TRUE. for a noncollinear calculation.

*  **ecfixed** = **0.0**

    ecfixed, qcutz, q2sigma:  parameters for modified functional to be used in variable-cell molecular dynamics (or in stress calculation). "ecfixed" is the value (in Rydberg) of the constant-cutoff; "qcutz" and "q2sigma" are the height and the width (in Rydberg) of the energy step for reciprocal vectors whose square modulus is greater than "ecfixed". In the kinetic energy, G^2 is
replaced by G^2 + qcutz * (1 + erf ( (G^2 - ecfixed)/q2sigma) )

*  **qcutz** = **0.0**

*  **q2sigma** = **0.1**

*  **input\_dft** = *read from pseudopotential files*

    Exchange-correlation functional

*  **exx\_fraction** = *depend on the specified functional*

    Fraction of EXX for hybrid functional calculations

*  **screening\_parameter** = **0.106**

    screening\_parameter for HSE like hybrid functionals

*  **exxdiv\_treatment** = **gygi-baldereschi**, vcut\_spherical, vcut\_ws, none

    Specific for EXX. It selects the kind of approach to be used for treating the Coulomb potential divergencies at small q vectors.

    gygi-baldereschi : appropriate for cubic and quasi-cubic supercells

    vcut\_spherical : appropriate for cubic and quasi-cubic supercells

    vcut\_ws : appropriate for strongly anisotropic supercells, see also ecutvcut.

    none : sets Coulomb potential at G, q=0 to 0.0 (required for GAU-PBE)

*  **x\_gamma\_extrapolation** = **.TRUE.**, .FALSE.

    Specific for EXX. If true, extrapolate the G=0 term of the potential. .FALSE. for GAU-PBE.

*  **ecutvcut** = **0.0**

    Reciprocal space cutoff for correcting Coulomb potential divergencies at small q vectors.

*  **nqx1, nqx2, nqx3** = *	INTEGER*

    three-dimensional mesh for q (k1-k2) sampling of the Fock operator (EXX). Can be smaller than
the number of k-points.

*  **lda\_plus\_u** = **.FALSE.**, .TRUE.

*  **lda\_plus\_u\_kind** = **0**, 1

    Specifies the type of DFT+U calculation: 0 for simplified version of Cococcioni and de Gironcoli, using Hubbard\_U; 1 for rotationally invariant scheme of Liechtenstein et al., using Hubbard\_U and Hubbard_J

*  **Hubbard\_U(i), i=1,ntyp** = **0.D0 for all species**

*  **Hubbard\_J0(i), i=1,ntype** = **0.D0 for all species**

*  **Hubbard\_alpha(i), i=1,ntyp** = **0.D0 for all species**

*  **Hubbard\_beta(i), i=1,ntyp** = **0.D0 for all species**

*  **Hubbard\_J(i,ityp)** = **0.D0 for all species**

    Hubbard\_J(i,ityp): J parameters (eV) for species ityp, used in DFT+U calculations (only for lda\_plus\_u\_kind=1)

    For p orbitals:  J = Hubbard\_J(1,ityp);

    For d orbitals:  J = Hubbard\_J(1,ityp), B = Hubbard\_J(2,ityp);

    For f orbitals:  J = Hubbard\_J(1,ityp), E2 = Hubbard\_J(2,ityp), E3= Hubbard\_J(3,ityp).

    If B or E2 or E3 are not specified or set to 0 they will be calculated from J using atomic ratios.

*  **starting\_ns\_eigenvalue(m,ispin,I)** = **-1.d0** *that means NOT SET*

*  **U\_projection\_type** = **'atomic'**, 'ortho-atomic', 'norm-atomic', 'file', 'pseudo'

    Only active when lda\_plus\_U is .TRUE., specifies the type of projector on localized orbital to be used in the DFT+U scheme.

    'atomic': use atomic wfc's (as they are) to build the projector

    'ortho-atomic': use Lowdin orthogonalized atomic wfc's

    'norm-atomic':  Lowdin normalization of atomic wfc.

    'file': use the information from file "prefix".at wfc that must have been generated previously, for instance by pmw.x

    'pseudo': use the pseudopotential projectors. The charge density outside the atomic core radii is excluded.

     N.B.: for atoms with +U, a pseudopotential with the all-electron atomic wavefunctions is required

*  **edir** = 1, 2, 3

    The direction of the electric field or dipole correction is parallel to the bg(:,edir) reciprocal lattice vector. Used only if tefield is .TRUE.

*  **emaxpos** = **0.5D0**

    Position of the maximum of the saw-like potential along crystal axis "edir", within the  unit cell, 0 < emaxpos < 1. Used only if tefield is .TRUE.

*  **eopreg** = **0.1D0**

    Zone in the unit cell where the saw-like potential decreases, 0 < eopreg < 1. Used only if tefield is .TRUE.

*  **eamp** = **0.001**

    Amplitude of the electric field, in ***Hartree*** a.u.; 1 a.u. = 51.4220632*10^10 V/m). Used only if tefield=.TRUE.The saw-like potential increases with slope "eamp" in the region from (emaxpos+eopreg-1) to (emaxpos), then decreases to 0 until (emaxpos+eopreg), in units of the crystal vector "edir". Important: the change of slope of this potential must be located in the empty region, or else unphysical forces will result.

*  **angle1(i), i=1,ntyp** = *REAL*

    The angle expressed in degrees between the initial magnetization and the z-axis. For noncollinear calculations only; index i runs over the atom types.

*  **angle2(i), i=1,ntyp** = *REAL*

    The angle expressed in degrees between the projection of the initial magnetization on x-y plane and the x-axis. For noncollinear calculations only.

*  **constrained\_magnetization** = **'none'**, 'total', 'atomic', 'total direction', atomic direction',

    Used to perform constrained calculations in magnetic systems.

    'none': no constraint

    'total': total magnetization is constrained by adding a penalty functional to the total energy:

        LAMBDA * SUM_{i} ( magnetization(i) - fixed_magnetization(i) )**2

     > where the sum over i runs over the three components of the magnetization. Lambda is a real number (see below). Noncolinear case only. Use "tot\_magnetization" for LSDA

    'atomic': atomic magnetization are constrained to the defined starting magnetization adding a penalty:

        LAMBDA * SUM_{i,itype} ( magnetic_moment(i,itype) - mcons(i,itype) )**2

     > where i runs over the cartesian components (or just z in the collinear case) and itype over the types (1-ntype).  mcons(:,:) array is defined from starting\_magnetization, (and angle1, angle2 in the non-collinear case). lambda is a real number

    'total direction':  the angle theta of the total magnetization with the z axis (theta = fixed\_magnetization(3)) is constrained:

          LAMBDA * ( arccos(magnetization(3)/mag_tot) - theta )**2

     > where mag\_tot is the modulus of the total magnetization.

    'atomic direction':
          not all the components of the atomic magnetic moment are constrained but only the cosine of angle1, and the penalty functional is:

          LAMBDA * SUM_{itype} ( mag_mom(3,itype)/mag_mom_tot - cos(angle1(ityp)) )**2

    N.B.: symmetrization may prevent to reach the desired orientation of the magnetization. Try not to start with very highly symmetric configurations or use the nosym flag (only as a last remedy)

*  **fixed\_magnetization(i), i=1,3** = **0.d0**

    total magnetization vector (x,y,z components) to be kept fixed when constrained\_magnetization='total'

*  **lambda** = **1.d0**

    parameter used for constrained\_magnetization calculations. N.B.: if the scf calculation does not converge, try to reduce lambda to obtain convergence, then restart the run with a larger lambda

*  **report** = **1**

    It is the number of iterations after which the program write all the atomic magnetic moments.

*  **lspinorb** = .TRUE., .FALSE.

    if .TRUE. the noncollinear code can use a pseudopotential with spin-orbit.

*  **assume\_isolated** = **'none'**, 'makov-payne'(m-p, mp), 'martyna-tuckerman'(m-t, mt), 'esm'

    Used to perform calculation assuming the system to be isolated (a molecule or a cluster in a 3D supercell).


    'none': regular periodic calculation w/o any correction.

    'makov-payne', 'm-p', 'mp' : the Makov-Payne correction to the total energy is computed.

    'martyna-tuckerman', 'm-t', 'mt' : Martyna-Tuckerman correction to both total energy and scf potential.

    'esm' :  Effective Screening Medium Method.

*  **esm\_bc** = **'pbc'**, 'bc1', 'bc2', 'bc3'

    If assume\_isolated = 'esm', determines the boundary conditions used for either side of the slab.

    'pbc' (default): regular periodic calculation (no ESM).

    'bc1' : Vacuum-slab-vacuum (open boundary conditions)

    'bc2' : Metal-slab-metal (dual electrode configuration). See also 'esm\_efield'.

    'bc3' : Vacuum-slab-metal

*  **esm\_w** = **0.d0**

    If assume\_isolated = 'esm', determines the position offset [in a.u.] of the start of the effective screening region, measured relative to the cell edge. (ESM region begins at
z = +/- [L\_z/2 + esm\_w] ).

*  **esm\_efield** = **0.d0**

    If assume\_isolated = 'esm' and esm\_bc = 'bc2', gives the magnitude of the electric field [Ry/a.u.] to be applied between semi-infinite ESM electrodes.

*  **esm_nfit** = **4**

    If assume\_isolated = 'esm', gives the number of z-grid points for the polynomial fit along the cell edge.

*  **vdw\_corr** = **'none'**,  'grimme-d2'(Grimme-D2, DFT-D, dft-d), 'TS'(ts, ts-vdw, ts-vdW, tkatchenko-scheffler), 'XDM'(xdm)

     'grimme-d2', 'Grimme-D2', 'DFT-D', 'dft-d': semiempirical Grimme's DFT-D2.

    'TS', 'ts', 'ts-vdw', 'ts-vdW', 'tkatchenko-scheffler': Tkatchenko-Scheffler dispersion corrections with first-principle derived C6 coefficients (implemented in CP only).

    'XDM', 'xdm': Exchange-hole dipole-moment model.

*  **london\_s6** = **0.75**

   global scaling parameter for DFT-D. Default is good for PBE.

*  **london\_rcut** = **200**

   cutoff radius (a.u.) for dispersion interactions

*  **xdm\_a1** = **0.6836**

   Damping function parameter a1 (adimensional). This value should change with the exchange-correlation functional. The default corresponds to PW86PBE.

*  **xdm\_a2** = **1.5045**

   Damping function parameter a2 (angstrom). This value should change with the exchange-correlation functional. The default corresponds to PW86PBE.

*  **space\_group** = **0**

   The number of the space group of the crystal, as given in the International Tables of Crystallography A (ITA). This allows to give in input only the inequivalent atomic positions. The positions of all the symmetry equivalent atoms are calculated by the code. Used only when the atomic positions are of type crystal\_sg.

*  **uniqueb** = **.FALSE.**, .TRUE.

   Used only for monoclinic lattices. If .TRUE. the b unique ibrav (-12 or -13) are used, and symmetry equivalent positions are chosen assuming that the two fold axis or the mirror normal is parallel to the b axis. If .FALSE. it is parallel to the c axis.

*  **origin\_choice** = **1**

   Used only for space groups that in the ITA allow the use of two different origins. origin\_choice=1, means the first origin, while origin\_choice=2 is the  second origin.

*  **rhombohedral** = **.TRUE.**, .FALSE.

   Used only for rhombohedral space groups. When .TRUE. the coordinates of the inequivalent atoms are given with respect to the rhombohedral axes, when .FALSE. the coordinates of the inequivalent atoms are given with respect to the hexagonal axes. They are converted internally to the rhombohedral axes and ibrav=5 is used in both cases.

/
####&ELECTRONS

*  **electron\_maxstep** = **100**

   maximum number of iterations in a scf step

*  **scf\_must\_converge** = **.TRUE.**, .FALSE.

   If .false. do not stop molecular dynamics or ionic relaxation when electron\_maxstep is reached. Use with care.

*  **conv\_thr** = **1.D-6**

   Convergence threshold for selfconsistency: estimated energy error < conv\_thr. For non-self-consistent calculations, conv\_thr is used to set the default value of the threshold (ethr) for iterative diagonalizazion(diago\_thr\_init).

*  **adaptive\_thr** = **.FALSE.**, .TRUE.

   If .TRUE. this turns on the use of an adaptive conv\_thr for the inner scf loops when using EXX.

*  **conv\_thr\_init** = **1.D-3**

   When adaptive\_thr = .TRUE. this is the convergence threshold used for the first scf cycle.

*  **conv\_thr\_multi** = **1.D-1**

   When adaptive\_thr = .TRUE. the convergence threshold for each scf cycle is given by:

      max( conv_thr, conv_thr_multi * dexx )

*  **mixing\_mode** = **'plain'**, 'TF'， 'local-TF'

   'plain' : charge density Broyden mixing

   'TF' : as above, with simple Thomas-Fermi screening (for highly homogeneous systems)

   'local-TF':  as above, with local-density-dependent TF screening (for highly inhomogeneous systems)

*  **mixing\_beta** = **0.7D0**

   mixing factor for self-consistency

*  **mixing\_ndim** = **8**

   number of iterations used in mixing scheme. If you are tight with memory, you may reduce it to 4 or so.

*  **mixing\_fixed\_ns** = **0**

   For DFT+U : number of iterations with fixed ns ( ns is the atomic density appearing in the Hubbard term ).

*  **diagonalization** = **'david'**, 'cg', 'cg-serial'

   'david': Davidson iterative diagonalization with overlap matrix (default). Fast, may in some rare cases fail.

   'cg' : conjugate-gradient-like band-by-band diagonalization. Typically slower than 'david' but it uses less memory and is more robust (it seldom fails)

   'cg-serial', 'david-serial': obsolete, use "-ndiag 1 instead". The subspace diagonalization in Davidson is performed by a fully distributed-memory parallel algorithm on 4 or more processors, by default. The allocated memory scales down with the number of procs. Procs involved in diagonalization can be changed with command-line option "-ndiag N". On multicore CPUs it is often convenient to let just one core per CPU to work on linear algebra.

*  **diago\_thr\_init** = **1.D-2** *for scf calculation starting from a superposition of atomic orbitals*, 1.D-5 *for scf calculation starting from a charge desity*, (conv_thr/N elec)/10 *for non-scf calculations*

   Convergence threshold (ethr) for iterative diagonalization (the check is on eigenvalue convergence).

*  **diago\_cg\_maxiter** = *INTEGER*

   For conjugate gradient diagonalization: max number of iterations

*  **diago\_david\_ndim** = **4**

   For Davidson diagonalization: dimension of workspace(number of wavefunction packets, at least 2 needed).A larger value may yield a somewhat faster algorithm but uses more memory. The opposite holds for smaller values. Try 2 if you are tight on memory or if your job is large: the speed penalty is often negligible.

*  **diago\_full\_acc** = **.FALSE.**, .TRUE.

   If .TRUE. all the empty states are diagonalized at the same level of accuracy of the occupied ones. Otherwise the empty states are diagonalized using a larger threshold (this should not affect total energy, forces, and other ground-state properties).

*  **efield** = **0.D0**

   Amplitude of the finite electric field (in Ry a.u.; 1 a.u. = 36.3609*10^10 V/m). Used only if lelfield=.TRUE. and if k-points (K\_POINTS card) are not automatic.

*  **efield\_cart(i), i=1,3** = **(0.D0, 0.D0, 0.D0)**

   Finite electric field (in Ry a.u.=36.3609*10^10 V/m) in cartesian axis. Used only if lelfield=.TRUE. and if k-points (K\_POINTS card) are automatic.

*  **startingpot** = 'atomic', 'file'

   'atomic': starting potential from atomic charge superposition (default for scf, \*relax, \*md )

   'file': start from existing "charge-density.xml" file in the directory specified by variables "prefix" and "outdir". For nscf and bands calculation this is the default and the only sensible possibility.

*  **startingwfc** = **'atomic+random'**, 'atomic', 'random', 'file'

   'atomic': start from superposition of atomic orbitals If not enough atomic orbitals are available, fill with random numbers the remaining wfcs The scf typically starts better with this option, but in some high-symmetry cases one can "loose" valence states, ending up in the wrong ground state.

   'atomic+random': as above, plus a superimposed "randomization" of atomic orbitals. Prevents the "loss" of states mentioned above.

   'random': start from random wfcs. Slower start of scf but safe. It may also reduce memory usage in conjunction with diagonalization='cg'

   'file': start from an existing wavefunction file in the directory specified by variables "prefix" and "outdir"

*  **tqr** = **.FALSE.**, .TRUE.

   If .true., use the real-space algorithm for augmentation charges in ultrasoft pseudopotentials. Must faster execution of ultrasoft-related calculations, but numerically less accurate than the default algorithm. Use with care and after testing!

\
###IONS *(input this namelist only if calculation = 'relax', 'md', 'vc-relax', 'vc-md')*  

*  **ion\_dynamics** = *CHARACTER*  

   Specify the type of ionic dynamics.

   * **CASE (calculation = 'relax')**

      'bfgs': (default) use BFGS quasi-newton algorithm, based on the trust radius procedure, for structural relaxation.

      'damp': use damped (quick-min Verlet) dynamics for structural relaxation. Can be used for constrained optimisation: see CONSTRAINTS card

   * **CASE (calculation = 'md')**

      'verlet': (default)use Verlet algorithm to integrate Newton's equation. For constrained dynamics, see CONSTRAINTS card

      'langevin' ion dynamics is over-damped Langevin

      'langevin-smc' over-damped Langevin with Smart Monte Carlo:

   * **CASE (calculation = 'vc-relax')**

      'bfgs': (default) use BFGS quasi-newton algorithm; cell\_dynamics must be 'bfgs' too

      'damp': use damped (Beeman) dynamics for structural relaxation

   * **CASE (calculation = 'vc-md')**

    'beeman': (default) use Beeman algorithm to integrate Newton's equation

*  **ion\_positions** = **'default'**, 'from\_input'

   'default': if restarting, use atomic positions read from the restart file; in all other cases, use atomic positions from standard input.

   'from\_input': restart the simulation with atomic positions read from standard input, even if restarting.

*  **pot\_extrapolation** = **'atomic'**, 'none', 'first\_order', 'second\_order'

   Used to extrapolate the potential from preceding ionic steps.

   'none': no extrapolation

   'atomic': extrapolate the potential as if it was a sum of atomic-like orbitals

   'first\_order' : extrapolate the potential with first-order formula

   'second\_order': as above, with second order formula

   Note: 'first\_order' and 'second\_order' extrapolation make sense only for molecular dynamics calculations.

*  **wfc\_extrapolation** = **'none'**, 'first\_order', 'second\_order'

   Used to extrapolate the wavefunctions from preceding ionic steps.

   'none': no extrapolation

   'first\_order': extrapolate the wave-functions with first-order formula.

   'second\_order': as above, with second order formula.

   Note: 'first\_order' and 'second-order' extrapolation make sense only for molecular dynamics calculations.

*  **remove\_rigid\_rot** = **.FALSE.**, .TRUE.

   This keyword is useful when simulating the dynamics and/or the thermodynamics of an isolated system. If set to true the total torque of the internal forces is set to zero by adding new forces that compensate the spurious interaction with the periodic images. This allows for the use of smaller supercells.

   *  **keywords used for molecular dynamics**

      *  **ion\_temperature** = **'not\_controlled'**, 'rescaling', 'rescale-v', 'rescale-T', 'berendsen', 'andersen', 'initial'

         'rescaling': control ionic temperature via velocity rescaling (first method) see parameters "tempw", "tolp", and "nraise" (for VC-MD only). This rescaling method is the only one currently implemented in VC-MD

         'rescale-v': control ionic temperature via velocity rescaling (second method) see parameters "tempw" and "nraise"

         'rescale-T': control ionic temperature via velocity rescaling (third method) see parameter "delta\_t"

         'reduce-T': reduce ionic temperature every "nraise" steps by the (negative) value "delta\_t"

         'berendsen': control ionic temperature using "soft" velocity rescaling - see parameters "tempw" and "nraise"

         'andersen': control ionic temperature using Andersen thermostat see parameters "tempw" and "nraise"

         'initial': initialize ion velocities to temperature "tempw" and leave uncontrolled further on

         'not\_controlled': ionic temperature is not controlled

      *  **tempw** = **300.D0**

         Starting temperature (Kelvin) in MD runs target temperature for most thermostats.

      *  **tolp** = **100.D0**

         Tolerance for velocity rescaling. Velocities are rescaled if the run-averaged and target temperature differ more than tolp.

      *  **delta\_t** = **1.D0**

         if ion\_temperature='rescale-T': at each step the instantaneous temperature is multiplied by delta\_t; this is done rescaling all the velocities.

         if ion\_temperature='reduce-T': every 'nraise' steps the instantaneous temperature is reduced by -delta\_T (i.e. delta\_t < 0 is added to T)

         The instantaneous temperature is calculated at the end of every ionic move and BEFORE rescaling. This is the temperature reported in the main output.

      *  **nraise** = **1**

         if ion\_temperature='reduce-T': every 'nraise' steps the instantaneous temperature is reduced by -delta\_T (.e. delta\_t is added to the temperature)

         if ion\_temperature='rescale-v': every 'nraise' steps the average temperature, computed from the last nraise steps, is rescaled to tempw

         if ion\_temperature='rescaling' and calculation='vc-md': every 'nraise' steps the instantaneous temperature is rescaled to tempw

         if ion\_temperature='berendsen': the "rise time" parameter is given in units of the time step: tau = nraise*dt, so dt/tau = 1/nraise

         if ion\_temperature='andersen': the "collision frequency" parameter is given as nu=1/tau defined above, so nu*dt = 1/nraise

      *  **refold\_pos** = **.FALSE.**, .TRUE.

         This keyword applies only in the case of molecular dynamics or damped dynamics. If true the ions are refolded at each step into the supercell.

   *  **keywords used only in BFGS calculations**

      *  **upscale** = **100.D0**

         Max reduction factor for conv\_thr during structural optimization conv\_thr is automatically reduced when the relaxation approaches convergence so that forces are still accurate, but conv\_thr will not be reduced to less that conv\_thr / upscale.

      *  **bfgs\_ndim** = **1**

         Number of old forces and displacements vectors used in the PULAY mixing of the residual vectors obtained on the basis of the inverse hessian matrix given by the BFGS algorithm. When bfgs\_ndim = 1, the standard quasi-Newton BFGS method is used. (bfgs only)

      *  **trust\_radius\_max** = **0.8D0**

         Maximum ionic displacement in the structural relaxation. (bfgs only)

      *  **trust\_radius\_min** = **1.D-3**

         Initial ionic displacement in the structural relaxation. (bfgs only)

      *  **w\_1** = **0.01D0**

      *  **w\_2** = **0.5D0**

      Parameters used in line search based on the Wolfe conditions. (bfgs only)

/
####&CELL *(input this namelist only if calculation = 'vc-relax', 'vc-md')*

*  **cell_dynamics** = *CHARACTER*

   *  **CASE ( calculation = 'vc-relax' )**

      'none': no dynamics

      'sd': steepest descent ( not implemented )

      'damp-pr': damped (Beeman) dynamics of the Parrinello-Rahman extended lagrangian

      'damp-w': damped (Beeman) dynamics of the new Wentzcovitch extended lagrangian

      'bfgs': BFGS quasi-newton algorithm (default). ion\_dynamics must be 'bfgs' too.

   *  **CASE ( calculation = 'vc-md' )**

      'none': no dynamics

      'pr': (Beeman) molecular dynamics of the Parrinello-Rahman extended lagrangian

      'w':  (Beeman) molecular dynamics of the new Wentzcovitch extended lagrangian

*  **press** = **0.D0**

      Target pressure [KBar] in a variable-cell md or relaxation run.

*  **wmass** = **0.75\*Tot_Mass/pi\*\*2** *for Parrinello-Rahman MD*, **0.75\*Tot_Mass/pi\*\*2/Omega\*\*(2/3)** *for Wentzcovitch MD*

   Fictitious cell mass [amu] for variable-cell simulations (both 'vc-md' and 'vc-relax')

*  **cell\_factor** = **1.2D0**

   Used in the construction of the pseudopotential tables. It should exceed the maximum linear contraction of the cell during a simulation.

*  **press\_conv\_thr** = **0.5D0 Kbar**

   Convergence threshold on the pressure for variable cell relaxation ('vc-relax' : note that the other convergence thresholds for ionic relaxation apply as well).

*  **cell\_dofree** = **'all'**, 'x', 'y', 'z', 'xy', 'xz', 'yz', 'xyz', 'shape', 'volume', '2Dxy', '2Dshape'

   Select which of the cell parameters should be moved:

   all     = all axis and angles are moved

   x       = only the x component of axis 1 (v1_x) is moved

   y       = only the y component of axis 2 (v2_y) is moved

   z       = only the z component of axis 3 (v3_z) is moved

   xy      = only v1_x and v2_y are moved

   xz      = only v1_x and v3_z are moved

   yz      = only v2_y and v3_z are moved

   xyz     = only v1_x, v2_y, v3_z are moved

   shape   = all axis and angles, keeping the volume fixed

   volume  = the volume changes, keeping all angles fixed (i.e. only celldm(1) changes)

   2Dxy    = only x and y components are allowed to change

   2Dshape = as above, keeping the area in xy plane fixed

/

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**

*  **prefix** = **pwscf**





        Power by markdown
